document.addEventListener("DOMContentLoaded", () => {
  // =========================
  // CONFIG
  // =========================
  const symbols = ["üåô", "üî•", "üåø", "üåä", "üóø", "ü™∂"];

  // ‚úÖ CHANGE THIS to your real solution
  const correctSequence = ["üåô", "üî•", "üåø", "üåä", "üóø", "ü™∂"];

  // What appears in the reveal modal
  const claimCodeText = "OUTCAST-S6-IDOL";

  // =========================
  // ELEMENTS
  // =========================
  const puzzle = document.getElementById("idol-puzzle");
  const boxes = document.querySelectorAll("#idol-puzzle .box");
  const msg = document.getElementById("message");

  const overlay = document.getElementById("revealOverlay");
  const closeBtn = document.getElementById("closeReveal");
  const copyBtn = document.getElementById("copyCode");
  const claimCode = document.getElementById("claimCode");

  claimCode.textContent = claimCodeText;

  // =========================
  // SOUND (generated via WebAudio)
  // - works on GitHub Pages
  // - no external files needed
  // =========================
  let audioEnabled = false;
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  const audioCtx = AudioCtx ? new AudioCtx() : null;

  function enableAudioOnFirstInteraction() {
    if (!audioCtx) return;
    if (audioEnabled) return;

    audioCtx.resume?.().catch(() => {});
    audioEnabled = true;

    // Remove once enabled
    document.removeEventListener("pointerdown", enableAudioOnFirstInteraction);
    document.removeEventListener("keydown", enableAudioOnFirstInteraction);
  }

  document.addEventListener("pointerdown", enableAudioOnFirstInteraction, { once: false });
  document.addEventListener("keydown", enableAudioOnFirstInteraction, { once: false });

  function playClick() {
    if (!audioCtx || !audioEnabled) return;

    const t = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();

    osc.type = "square";
    osc.frequency.setValueAtTime(1800, t);
    osc.frequency.exponentialRampToValueAtTime(900, t + 0.03);

    gain.gain.setValueAtTime(0.0001, t);
    gain.gain.exponentialRampToValueAtTime(0.07, t + 0.005);
    gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.06);

    osc.connect(gain);
    gain.connect(audioCtx.destination);

    osc.start(t);
    osc.stop(t + 0.07);
  }

  function playDrum() {
    if (!audioCtx || !audioEnabled) return;

    const t = audioCtx.currentTime;

    // Low sine "thump"
    const osc = audioCtx.createOscillator();
    osc.type = "sine";
    osc.frequency.setValueAtTime(90, t);
    osc.frequency.exponentialRampToValueAtTime(55, t + 0.18);

    // Body envelope
    const gain = audioCtx.createGain();
    gain.gain.setValueAtTime(0.0001, t);
    gain.gain.exponentialRampToValueAtTime(0.9, t + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.25);

    // Add a short noise burst for ‚Äúskin hit‚Äù
    const noise = audioCtx.createBufferSource();
    const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.12, audioCtx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < data.length; i++) {
      data[i] = (Math.random() * 2 - 1) * (1 - i / data.length);
    }
    noise.buffer = buffer;

    const noiseGain = audioCtx.createGain();
    noiseGain.gain.setValueAtTime(0.0001, t);
    noiseGain.gain.exponentialRampToValueAtTime(0.22, t + 0.008);
    noiseGain.gain.exponentialRampToValueAtTime(0.0001, t + 0.12);

    const noiseFilter = audioCtx.createBiquadFilter();
    noiseFilter.type = "lowpass";
    noiseFilter.frequency.setValueAtTime(700, t);

    noise.connect(noiseFilter);
    noiseFilter.connect(noiseGain);
    noiseGain.connect(audioCtx.destination);

    // Connect thump
    osc.connect(gain);
    gain.connect(audioCtx.destination);

    osc.start(t);
    osc.stop(t + 0.26);

    noise.start(t);
    noise.stop(t + 0.13);
  }

  // =========================
  // UI HELPERS
  // =========================
  let failCount = 0;
  let messageTimer = null;

  function setMessage(text, big = false) {
    if (!msg) return;
    msg.textContent = text || "";
    msg.classList.toggle("big", !!big);

    if (messageTimer) clearTimeout(messageTimer);
    if (text) {
      messageTimer = setTimeout(() => {
        msg.textContent = "";
        msg.classList.remove("big");
      }, 2500);
    }
  }

  function shakePuzzle() {
    puzzle.classList.remove("shake");
    // force reflow so animation retriggers
    void puzzle.offsetWidth;
    puzzle.classList.add("shake");
  }

  function tickSymbol(el) {
    el.classList.remove("tick");
    void el.offsetWidth;
    el.classList.add("tick");
    setTimeout(() => el.classList.remove("tick"), 140);
  }

  // =========================
  // SYMBOL CYCLING
  // =========================
  boxes.forEach((box) => {
    const symbolDiv = box.querySelector(".symbol");
    const up = box.querySelector(".up");
    const down = box.querySelector(".down");

    up.addEventListener("click", () => {
      let i = symbols.indexOf(symbolDiv.textContent);
      symbolDiv.textContent = symbols[(i + 1) % symbols.length];
      tickSymbol(symbolDiv);
      playClick(); // subtle lock click
    });

    down.addEventListener("click", () => {
      let i = symbols.indexOf(symbolDiv.textContent);
      symbolDiv.textContent = symbols[(i - 1 + symbols.length) % symbols.length];
      tickSymbol(symbolDiv);
      playClick(); // subtle lock click
    });
  });

  // =========================
  // MODAL CONTROLS
  // =========================
  function openReveal() {
    overlay.classList.add("show");
    overlay.setAttribute("aria-hidden", "false");
    document.body.style.overflow = "hidden";
  }

  function closeReveal() {
    overlay.classList.remove("show");
    overlay.setAttribute("aria-hidden", "true");
    document.body.style.overflow = "";
  }

  overlay.addEventListener("click", (e) => {
    if (e.target === overlay) closeReveal();
  });

  closeBtn.addEventListener("click", closeReveal);

  document.addEventListener("keydown", (e) => {
    if (e.key === "Escape" && overlay.classList.contains("show")) closeReveal();
  });

  copyBtn.addEventListener("click", async () => {
    try {
      await navigator.clipboard.writeText(claimCodeText);
      copyBtn.textContent = "Copied!";
      setTimeout(() => (copyBtn.textContent = "Copy Claim Code"), 1200);
    } catch {
      const temp = document.createElement("textarea");
      temp.value = claimCodeText;
      document.body.appendChild(temp);
      temp.select();
      document.execCommand("copy");
      document.body.removeChild(temp);
      copyBtn.textContent = "Copied!";
      setTimeout(() => (copyBtn.textContent = "Copy Claim Code"), 1200);
    }
  });

  // =========================
  // SUBMIT CHECK
  // =========================
  document.getElementById("submitPuzzle").addEventListener("click", () => {
    const attempt = Array.from(boxes).map((b) => b.querySelector(".symbol").textContent);

    if (attempt.join("") === correctSequence.join("")) {
      // Success: low drum hit + reveal
      setMessage("You found something...", false);
      playDrum();
      openReveal();
      return;
    }

    // Incorrect: shake + attempt tracking
    failCount += 1;
    shakePuzzle();

    if (failCount === 7) {
      setMessage("SIX SEVENNNNNN!!!", true);
    } else {
      setMessage(`Incorrect. Attempts: ${failCount}`, false);
    }
  });

});
